# ðŸ’³ Payment System - Interview Cheatsheet

> Based on Alex Xu's System Design Interview Volume 2 - Chapter 11

## Quick Reference Card

| Component | Purpose | Key Points |
|-----------|---------|------------|
| **Payment Service** | Accepts payment events, orchestrates flow | Idempotency check, creates payment orders |
| **Payment Executor** | Talks to PSP (Stripe, PayPal) | Sends payment requests, handles responses |
| **Payment Service Provider (PSP)** | External â€” processes credit card payments | Stripe, Braintree, PayPal, Adyen |
| **Card Schemes** | External â€” Visa, Mastercard networks | PSP talks to card schemes, not us |
| **Ledger** | Double-entry accounting records | Append-only, debit == credit always |
| **Wallet** | Tracks seller account balances | Updated after successful payment |
| **Reconciliation** | Cross-system consistency check | Compares our records vs PSP settlement files |

---

## The Story: Building a Payment System

You're building the payment backend for an e-commerce platform like Amazon. When a customer clicks "Pay", your system must move money from the buyer to the seller â€” reliably, exactly once, and with a full audit trail. Let's design this step by step.

---

## 1. What Are We Building? (Requirements)

### Functional Requirements

- **Pay-in flow**: Receive money from customers on behalf of sellers
- **Pay-out flow**: Send money to sellers (e.g., monthly settlement)
- Use third-party PSPs (Stripe, PayPal) â€” we do NOT process card data ourselves
- Support reconciliation between internal and external systems

### Non-Functional Requirements

- **Reliability & fault tolerance**: Failed payments must be handled gracefully
- **Exactly-once processing**: A payment must never be charged twice
- **Consistency**: Internal records must match PSP records
- **Security**: Never store raw credit card numbers (PCI compliance)

---

## 2. Back-of-the-Envelope Estimation

| Metric | Calculation | Result |
|--------|------------|--------|
| **Transactions/day** | Given | 1 million |
| **TPS** | 1M / 10âµ seconds | **~10 TPS** |
| **Peak TPS** | 10 Ã— 5 (peak factor) | **~50 TPS** |

**Key insight**: 10 TPS is low for a database. This is NOT a throughput problem. The challenge is **correctness** â€” handling money correctly, exactly once, with full audit trails. The focus of this design is on reliability, idempotency, and consistency, not on scaling.

---

## 3. Pay-in Flow (Customer Pays)

This is the core flow â€” what happens when a customer clicks "Pay" on an e-commerce checkout page.

### Components Involved

```
                Internal                    â”‚            External
                                            â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    Payment    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Payment  â”‚â”€â”€â”€  Order  â”€â”€â†’â”‚ Payment  â”‚â”€â”€â”¼â”€â†’â”‚   PSP   â”‚â”€â”€â†’ â”‚   Card     â”‚
  â”‚  Service  â”‚               â”‚ Executor â”‚  â”‚  â”‚(Stripe, â”‚    â”‚  Schemes   â”‚
  â”‚           â”‚               â”‚          â”‚  â”‚  â”‚ PayPal) â”‚    â”‚(Visa, MC)  â”‚
  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†™     â†˜                       â”‚        â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”    â”‚
â”‚ Ledger â”‚ â”‚ Wallet â”‚         â”‚  DB    â”‚    â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
    â–¼          â–¼                            â”‚
  â”Œâ”€â”€â”       â”Œâ”€â”€â”                           â”‚
  â”‚DBâ”‚       â”‚DBâ”‚                           â”‚
  â””â”€â”€â”˜       â””â”€â”€â”˜                           â”‚
```

### What Does Each Component Do?

| Component | Responsibility |
|-----------|---------------|
| **Payment Service** | Entry point. Validates request, checks idempotency, creates payment order, coordinates the flow |
| **Payment Executor** | Single responsibility: call the PSP. Handles PSP-specific protocols, retries, timeouts |
| **PSP (External)** | Processes the actual card charge. We send amount + card token, they return success/failure |
| **Ledger** | Records double-entry accounting entries (debit + credit). Append-only, never modified |
| **Wallet** | Tracks each seller's current balance. Updated when money comes in or goes out |

### Step-by-Step Flow

```
â‘  User clicks "Pay" on checkout page
   â”‚
â‘¡ Payment Service receives the payment event
   â”œâ”€â”€ Check idempotency key (have we seen this request before?)
   â”‚   (idempotency_key is a UUID generated by the CLIENT, sent in the request header)
   â”œâ”€â”€ If duplicate â†’ return cached result (no double charge)
   â””â”€â”€ If new â†’ INSERT into payment_orders table (status: CREATED)
   â”‚
â‘¢ Payment Service sends Payment Order to Payment Executor
   â”‚
â‘£ Payment Executor updates payment_orders status â†’ EXECUTING
   â”‚
â‘¤ Payment Executor calls PSP (e.g., Stripe API)
   â””â”€â”€ PSP talks to Card Schemes (Visa/Mastercard) to move money
   â”‚
â‘¥ PSP returns result â†’ Payment Executor updates status â†’ SUCCESS or FAILED
   â”‚
â‘¦ On success â†’ update Wallet (seller's balance += amount)
   â”‚   (one UPDATE to the wallets table)
   â”‚
â‘§ On success â†’ update Ledger (double-entry: debit buyer, credit seller)
   â”‚   (two INSERTs to the ledger_entries table â€” append-only, never modified)
   â”‚
   All of steps â‘¥-â‘§ happen in a SINGLE database transaction (all-or-nothing)
```

### Before the Flow: Who Generates the Idempotency Key?

The **client** generates it (a UUID) before sending the request.

**Why the client?** If the request times out mid-flight, the client doesn't know if the server processed it. On retry, the client sends the **same key** â†’ server deduplicates â†’ no double charge.

**Why not the server?** The client would need an extra round-trip first ("give me a key, then I'll send the payment"), adding latency and complexity. The whole point is the client can retry safely without any coordination.

### Where Is the Data Stored?

In a straightforward payment system, all internal services share **one database** (or a few tables in the same DB). There's no need for separate databases per service at 10 TPS:

```
Single Database (e.g., MySQL):
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  payment_orders      â”‚ â† Payment Service + Payment Executor read/write here
  â”‚  ledger_entries      â”‚ â† Ledger Service writes here (append-only)
  â”‚  wallets             â”‚ â† Wallet balance updated here
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The `payment_orders` table tracks the lifecycle: **CREATED â†’ EXECUTING â†’ SUCCESS/FAILED**. Payment Service creates the row (CREATED), Payment Executor updates it to EXECUTING when it calls PSP, then to SUCCESS/FAILED when PSP responds. It's one table, not separate DBs.

### Wallet vs Ledger â€” Why Both?

| | Wallet | Ledger |
|---|---|---|
| **Question it answers** | "How much money does Seller Bob have **right now**?" | "What happened to **every dollar**, ever?" |
| **Data** | Single running balance per seller | Every transaction as two entries (debit + credit) |
| **Mutable?** | Yes â€” balance updates on every transaction | **No â€” append-only, immutable** |
| **Used for** | Pay-out eligibility, balance display | Auditing, compliance, debugging, financial reports |
| **Analogy** | Checking your bank balance on the app | Downloading your full bank statement |

> **Why not just use the Ledger?** You could derive the balance from the Ledger (`SUM(credits) - SUM(debits)` for a seller), but scanning millions of entries per query is slow. The Wallet is a pre-computed cache of the current balance.


---

## 4. Pay-out Flow (Seller Gets Paid)

Pay-out is the reverse â€” the platform sends accumulated money to sellers (e.g., monthly).

```
â‘  Finance team or automated scheduler triggers pay-out
   â”‚
â‘¡ Payment Service creates a pay-out order
   â”‚
â‘¢ Payment Executor calls PSP's pay-out API
   â””â”€â”€ PSP transfers money to seller's bank account (via ACH, wire, etc.)
   â”‚
â‘£ PSP confirms transfer
   â”‚
â‘¤ Update Wallet (seller's balance -= amount)
   â”‚
â‘¥ Update Ledger (debit platform, credit seller's bank)
```

**Pay-in vs Pay-out:**

| | Pay-in | Pay-out |
|---|---|---|
| **Direction** | Customer â†’ Platform (on behalf of seller) | Platform â†’ Seller's bank |
| **Trigger** | Customer clicks "Pay" | Scheduled (monthly) or manual |
| **PSP API** | Charge/capture API | Payout/transfer API |
| **Speed** | Seconds (real-time) | Hours to days (batch) |
| **Frequency** | Every purchase | Periodic (daily/weekly/monthly) |

---

## 5. API Design

### Pay-in: Create a Payment

```
POST /v1/payments
Headers:
  Idempotency-Key: "d7e8f9a0-1b2c-3d4e-5f6a-7b8c9d0e1f2a"

Body: {
  "buyer_id": "user_123",
  "seller_id": "seller_456",
  "amount": 99.99,
  "currency": "USD",
  "order_id": "order_789"
}

Response: {
  "payment_order_id": "pay_abc123",
  "status": "EXECUTING",
  "psp_redirect_url": "https://stripe.com/checkout/session/xyz"
}
```

> The `Idempotency-Key` is passed in the HTTP **header**, not the body. This is the standard pattern (Stripe, PayPal, etc.) â€” it ensures retries don't create duplicate charges.

### Multi-Seller Orders (e.g., Amazon Checkout)

When a buyer's cart has items from multiple sellers, the **Order Service** (not the client) calls Payment Service with all the line items:

```
POST /v1/payments
Headers:
  Idempotency-Key: "unique-uuid-for-order-789"

Body: {
  "buyer_id": "user_123",
  "order_id": "order_789",
  "total_amount": 100.00,
  "currency": "USD",
  "line_items": [
    { "seller_id": "seller_A", "amount": 40.00, "sub_order_id": "sub_001" },
    { "seller_id": "seller_B", "amount": 35.00, "sub_order_id": "sub_002" },
    { "seller_id": "seller_C", "amount": 25.00, "sub_order_id": "sub_003" }
  ]
}
```

What Payment Service does internally:

1. **One PSP charge** for `total_amount` ($100) â€” buyer sees a single charge on their card.
2. **One `payment_order` per line item** for internal tracking:

```
Buyer pays $100 (single PSP charge)
  â”œâ”€â”€ payment_order_1 â†’ Seller A: $40 (minus platform fee)
  â”œâ”€â”€ payment_order_2 â†’ Seller B: $35 (minus platform fee)
  â””â”€â”€ payment_order_3 â†’ Seller C: $25 (minus platform fee)
```

3. Each seller's **Wallet** is credited separately, each gets its own **Ledger** entries, and each is **paid out independently** (e.g., monthly).

> **Key insight:** The PSP charge is one transaction for the total. The splitting into per-seller records is an **internal concern** â€” the buyer and the PSP see a single payment.

### Get Payment Status

```
GET /v1/payments/{payment_order_id}
Response: {
  "payment_order_id": "pay_abc123",
  "status": "SUCCESS",
  "amount": 99.99,
  "psp_transaction_id": "psp_tx_789"
}
```

### Pay-out: Initiate Seller Payment

```
POST /v1/payouts
Body: {
  "seller_id": "seller_456",
  "amount": 5000.00,
  "currency": "USD"
}
```

---

## 6. Hosted Payment Page

### Why Don't We Handle Card Data Ourselves?

Handling credit card numbers directly requires **PCI DSS Level 1 compliance** â€” the highest security standard. This means:
- Annual on-site security audits
- Quarterly network scans
- Encryption of all stored card data
- Extremely expensive and complex

**Instead, we use a "Hosted Payment Page"** â€” the PSP provides the payment form, and card data never touches our servers.

### How It Works

This is the **detailed view of how steps â‘£-â‘¥ in the pay-in flow (Section 3) actually happen** â€” showing the browser redirects and PSP interaction:

```
                            Client Browser
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Checkout    â”‚    â”‚  Hosted Payment   â”‚    â”‚ Payment Completion  â”‚
  â”‚     Page      â”‚    â”‚      Page         â”‚    â”‚       Page          â”‚
  â”‚   (Our Site)  â”‚    â”‚   (PSP's Page)    â”‚    â”‚    (Our Site)       â”‚
  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚               â”‚          â”‚                     â–²
    â‘  Checkout      â‘¤ Display  â‘¥ User enters        â‘§ Redirect
         â”‚            PSP page   card details &         to our
         â”‚            with token  starts payment      completion
         â–¼               â–²          â”‚                   page
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚          â”‚
  â”‚   Payment    â”‚       â”‚          â”‚
  â”‚   Service    â”‚â”€â”€â”€â”   â”‚          â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚          â”‚
                     â–¼   â”‚          â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚     â‘¦    â”‚              â”‚
               â”‚   Payment   â”‚â”€â”€â”€â”€â”€â”€â”˜    â”€â”€â”€â”€â†’ â”‚     PSP      â”‚
               â”‚   Executor  â”‚                  â”‚  (Stripe,    â”‚
               â”‚             â”‚â†â‘¡ Create paymentâ†’â”‚   Braintree) â”‚
               â”‚             â”‚  with idempotency â”‚              â”‚
               â”‚             â”‚      key          â”‚              â”‚
               â”‚             â”‚â†â‘¢ Return tokenâ”€â”€â”€â”‚              â”‚
               â”‚             â”‚                  â”‚              â”‚
               â”‚             â”‚â†â‘¨ Webhookâ”€â”€â”€â”€â”€â”€â”€â”€â”‚              â”‚
               â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                 â‘£ Store token
                      â”‚
                      â–¼
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚   DB   â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  Payment System
```

**Step-by-step:**

| Step | Who | What happens |
|------|-----|-------------|
| â‘  | User | Clicks "Checkout" on our site |
| â‘¡ | Payment Executor â†’ PSP | Creates payment session with `{ amount, currency, idempotency_key, success_url, cancel_url }`. The URLs tell PSP where to redirect the user after payment. |
| â‘¢ | PSP â†’ Payment Executor | Returns a **payment token** |
| â‘£ | Payment Executor â†’ DB | Stores the token (linked to order, status: EXECUTING) |
| â‘¤ | Payment Executor â†’ Browser | Redirects user to PSP's Hosted Payment Page |
| â‘¥ | User â†’ PSP | Enters card details **on PSP's page** â€” card data never touches our servers |
| â‘¦ | PSP | Processes the payment |
| â‘§a | PSP â†’ Browser | Redirects user to `success_url` â€” but this is just a redirect, **NOT** confirmation of payment |
| â‘§b | PSP â†’ Payment Executor | Sends **webhook** with the final result (SUCCESS/FAILED) â€” this is the **authoritative** confirmation |

> **â‘§a and â‘§b happen independently and almost simultaneously** â€” they're not sequential. The redirect is a browser action; the webhook is a server-to-server HTTP POST. Either can arrive first. Our success page should show "Processing..." until the webhook is received and verified. Only then do we update the order status.

> **How this connects to Section 3:** Steps â‘ -â‘¢ here are the detailed breakdown of pay-in step â‘¤ ("Payment Executor calls PSP"). Step â‘§b (webhook) is the trigger for pay-in step â‘¥ ("PSP returns result"). After the webhook, the normal pay-in flow continues â€” update Wallet, update Ledger.

### What Is the PSP Token and Why Is It Important?

The PSP token is an **opaque string** (e.g., `cs_live_xyz123`) â€” just an ID. It doesn't "contain" any payment data. It points to a payment session stored **on PSP's servers** (amount, currency, merchant, allowed payment methods, return URLs).

**It serves 3 purposes:**

| Purpose | How |
|---------|-----|
| **Redirect the user** | We embed the token in the URL: `stripe.com/checkout/cs_live_xyz123` â†’ takes user to the correct payment page for *their* $99.99 order |
| **Match the webhook** | When PSP sends "payment done," it includes this token â†’ we look it up in our DB to find which `payment_order_id` it belongs to |
| **We never see card data** | User enters card details on PSP's page. The token is the *only* thing flowing through our system â€” not card numbers |

> **Without the token**, we'd have no way to connect the PSP's "payment succeeded" webhook back to the correct order in our system. It's the **glue between our world and the PSP's world.**

**Token is NOT the same as `payment_order_id`:**

| ID | Who creates it | Direction | Example |
|----|---------------|-----------|---------|
| `payment_order_id` | **Us** | Internal only | `pay_abc123` |
| `psp_token` | **PSP** | PSP â†’ Us | `cs_live_xyz123` |

### Why Do We Send an Idempotency Key to the PSP?

Same concept as the client sending *us* an idempotency key, but one layer deeper â€” now **we** are the client and **Stripe** is the server.

If our "create session" call to Stripe times out, we retry. Without an idempotency key, Stripe creates a **second** session â†’ two payment sessions for the same order. With it, Stripe sees "I've already processed this key" â†’ returns the **same** session.

### Why Webhooks?

The PSP sends us the result via a **webhook** (an HTTP POST to our server) instead of us polling, because:
- Payment might take seconds or minutes (3D Secure, bank verification)
- We don't want to keep a connection open waiting
- Webhook is asynchronous â€” PSP notifies us when ready

---

## 7. Data Model

### Payment Order Table

```sql
CREATE TABLE payment_orders (
    payment_order_id    VARCHAR(36) PRIMARY KEY,
    buyer_id            VARCHAR(36) NOT NULL,
    seller_id           VARCHAR(36) NOT NULL,
    amount              DECIMAL(18,2) NOT NULL,
    currency            VARCHAR(3) NOT NULL,
    order_id            VARCHAR(36) NOT NULL,
    idempotency_key     VARCHAR(64) UNIQUE NOT NULL,
    status              ENUM('CREATED','EXECUTING','SUCCESS','FAILED') NOT NULL,
    psp_token           VARCHAR(64),          -- PSP's session ID (returned in step â‘¢, webhook references this same ID in step â‘§b)
    created_at          TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at          TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    INDEX idx_psp_token (psp_token)           -- webhook lookup: PSP sends token â†’ we find the order in O(log n)
);
```

### Why Store `idempotency_key` with a UNIQUE Constraint?

This is how we prevent double charging:
1. Client sends payment request with `Idempotency-Key: abc123`
2. We try to INSERT a new payment_order with `idempotency_key = 'abc123'`
3. If the key already exists â†’ UNIQUE constraint violation â†’ return the existing order
4. If it's new â†’ INSERT succeeds â†’ process the payment

The database enforces uniqueness â€” even if two identical requests arrive at the same millisecond, only one INSERT succeeds.

### Ledger Table (Append-Only)

```sql
CREATE TABLE ledger_entries (
    entry_id            BIGINT AUTO_INCREMENT PRIMARY KEY,
    payment_order_id    VARCHAR(36) NOT NULL,
    account             VARCHAR(64) NOT NULL,
    entry_type          ENUM('DEBIT','CREDIT') NOT NULL,
    amount              DECIMAL(18,2) NOT NULL,
    created_at          TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_payment_order (payment_order_id)
);
```

> **Append-only**: Ledger entries are never updated or deleted. This is critical for audit trails and financial compliance.

### Wallet Table

```sql
CREATE TABLE wallets (
    seller_id           VARCHAR(36) PRIMARY KEY,
    balance             DECIMAL(18,2) NOT NULL DEFAULT 0.00,
    last_updated        TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

---

## 8. Double-Entry Ledger System

### What Is Double-Entry Bookkeeping?

Every financial transaction creates **exactly two entries** that balance each other:
- One **debit** (money leaves an account)
- One **credit** (money enters an account)

**The invariant**: Total debits across ALL accounts must ALWAYS equal total credits. If they don't, something is wrong.

### Example: Alice Pays $100 for a Product from SellerBob

```
Entry 1 (DEBIT):   buyer:alice     -$100   (money leaves Alice)
Entry 2 (CREDIT):  seller:bob      +$100   (money arrives at Bob)
                                   â”€â”€â”€â”€â”€
                   Total debit  =  $100
                   Total credit =  $100  âœ“ Balanced
```

### Why Double-Entry for a Payment System?

| Benefit | How |
|---------|-----|
| **Error detection** | If debits â‰  credits, something went wrong |
| **Audit trail** | Every dollar movement is traceable to two entries |
| **Financial reporting** | Standard accounting â€” auditors understand it |
| **Immutability** | Entries are append-only, never modified (prevents fraud) |

### How Corrections Work

If a payment needs to be reversed (refund), you don't *delete* the original entries. You create **new reversal entries**:

```
Original payment:
  DEBIT   buyer:alice     $100
  CREDIT  seller:bob      $100

Refund:
  DEBIT   seller:bob      $100   (money leaves Bob)
  CREDIT  buyer:alice     $100   (money returns to Alice)

Net effect: $0 moved. All 4 entries remain in the ledger for audit.
```

---

## 9. PSP Integration Details

### What Does a PSP Do?

A PSP (Payment Service Provider) like Stripe or PayPal acts as a **middleman** between us and the card networks:

```
Our System â†’ PSP (Stripe) â†’ Card Network (Visa) â†’ Issuing Bank â†’ Customer's Account
```

We never talk to Visa/Mastercard directly. The PSP handles:
- Card data encryption and tokenization
- Communication with card networks
- Fraud detection
- PCI compliance
- Multiple payment methods (credit card, debit card, bank transfer, etc.)

### PSP Integration Pattern (Consistent with Hosted Payment Flow â€” Section 6)

```
Our Payment Executor                          PSP (Stripe)
       â”‚                                            â”‚
       â”‚â”€â”€ POST /v1/checkout/sessions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚  (step â‘¡)
       â”‚   { amount: 9999,                          â”‚
       â”‚     currency: "usd",                       â”‚
       â”‚     success_url: "https://our-site/ok",    â”‚
       â”‚     cancel_url: "https://our-site/cancel", â”‚
       â”‚     idempotency_key: "idem_xyz" }          â”‚
       â”‚                                            â”‚
       â”‚ â†â”€â”€ 200 OK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  (step â‘¢)
       â”‚   { psp_token: "cs_live_xyz123" }          â”‚
       â”‚                                            â”‚
  ... user pays on Stripe's hosted page ...         â”‚
       â”‚                                            â”‚
       â”‚ â†â”€â”€ Webhook POST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚  (step â‘§b)
       â”‚   { event: "payment.succeeded",            â”‚
       â”‚     psp_token: "cs_live_xyz123" }          â”‚
```

> **Idempotency flows through the entire chain:** Client â†’ Our System â†’ PSP. Every layer deduplicates. If our request to Stripe times out, we retry with the same `idempotency_key` â†’ Stripe returns the same session instead of creating a duplicate.

---

## 10. Reconciliation

### What Is Reconciliation?

Reconciliation is the process of **comparing our internal records with the PSP's records** to find and fix discrepancies. It runs as a **batch job** (typically daily).

### Why Is It Needed?

In distributed systems, things go wrong. Since we only update to SUCCESS after the webhook, the realistic failure scenarios are:

- **PSP charged the customer, but webhook never arrived** â€” PSP says SUCCESS, we're stuck at EXECUTING. Customer is charged but we don't know.
- **Webhook arrived, but our handler crashed mid-processing** â€” payment_orders updated to SUCCESS, but wallet/ledger update failed. Money received but not credited to seller.
- **PSP retried webhook, we processed it twice** â€” unlikely with idempotency, but possible if our dedup logic has a bug.
- **Amount mismatch** â€” rounding or currency conversion differences between our records and PSP's records.

### How It Works

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Our System  â”‚                              â”‚   PSP    â”‚
â”‚             â”‚                              â”‚          â”‚
â”‚ Payment DB  â”‚     Reconciliation Job       â”‚Settlementâ”‚
â”‚ Ledger DB   â”‚â—„â”€â”€â”€â”€â”€â”€â”€ compares â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  File    â”‚
â”‚             â”‚                              â”‚ (daily)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                                        â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Find mismatches â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
                    â”‚  Mismatch   â”‚
                    â”‚  Resolution â”‚
                    â”‚  (manual or â”‚
                    â”‚  automated) â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Step-by-Step

1. **PSP provides a settlement file** (usually daily CSV/JSON) listing all transactions they processed
2. **Reconciliation job** reads our Payment DB + Ledger and compares against the settlement file
3. **For each transaction**, compare:
   - Does the transaction exist in both systems?
   - Do the amounts match?
   - Do the statuses match (SUCCESS/FAILED)?
4. **Flag mismatches** for investigation:
   - **Missing in our system**: PSP processed it, we didn't record it â†’ create the missing record
   - **Missing in PSP**: We recorded it, PSP has no record â†’ investigate, possibly refund
   - **Amount mismatch**: Different amounts â†’ investigate, fix the discrepancy
   - **Status mismatch**: We say SUCCESS, PSP says FAILED â†’ update our status, possibly refund

### Three-Way Reconciliation

In a complete system, reconciliation happens between THREE sources:

```
1. Our Payment DB     â†â†’  2. PSP Settlement File  â†â†’  3. Bank Statements
```

This is called **three-way reconciliation** â€” the gold standard for payment systems.

---

## 11. Handling Payment Processing Delays

### The Problem

Not all payments complete instantly. Some scenarios:
- **3D Secure**: Bank asks user to enter OTP â†’ takes 30 seconds to 5 minutes
- **Bank transfers**: Settlement takes 1-3 business days
- **Manual review**: PSP flags transaction for fraud review â†’ hours to days

### Solution: Asynchronous Status Updates via Webhooks

```
â‘  Client submits payment â†’ Status: EXECUTING
   â”‚
â‘¡ We return immediately: "Payment is being processed"
   â”‚
â‘¢ ... time passes (seconds to days) ...
   â”‚
â‘£ PSP sends webhook: "Payment succeeded" or "Payment failed"
   â”‚
â‘¤ We update payment_order status
   â”‚
â‘¥ Notify user (push notification, email, or next page load)
```

### Payment Order Status Machine

```
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚   CREATED   â”‚
            â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                   â”‚ (sent to PSP)
            â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
            â”‚  EXECUTING  â”‚
            â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”˜
               â”‚       â”‚
      (webhook â”‚       â”‚ (webhook
       success)â”‚       â”‚  failure)
        â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”  â”Œâ”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ SUCCESS â”‚  â”‚  FAILED   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                           â”‚ (retry?)
                    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
                    â”‚  EXECUTING  â”‚  (back to executing on retry)
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

> **Key design point**: The client should NOT wait for the payment to complete. Return immediately with `status: EXECUTING` and use webhooks + polling for final status.

---

## 12. Communication Among Internal Services

### The Problem

When a payment succeeds, multiple internal systems need to know:
- **Payment System**: Update order status
- **Analytics Service**: Record the transaction for reports
- **Billing Service**: Generate invoice
- **Accounting Service**: Update books

If we use direct synchronous calls, one slow/failed service blocks the entire chain.

### Solution: Message Queue (Kafka)

```
                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                    â”‚  Payment System  â”‚
                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                             â”‚
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
Events â”€â”€â†’  â”Œâ”€â”€â” â”Œâ”€â”€â” â”Œâ”€â”€â”   â”‚           Kafka              â”‚
            â”‚m4â”‚ â”‚m3â”‚ â”‚m2â”‚   â”‚   (payment.events topic)     â”‚
            â””â”€â”€â”˜ â””â”€â”€â”˜ â””â”€â”€â”˜   â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                                â”‚          â”‚           â”‚
                         â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â” â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€ â”
                         â”‚Analyticsâ”‚ â”‚ Billing  â”‚  â”‚Accountingâ”‚
                         â”‚ Service â”‚ â”‚ Service  â”‚  â”‚ Service  â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why Kafka?**

| Benefit | Explanation |
|---------|------------|
| **Decoupling** | Payment system doesn't know/care about consumers |
| **Reliability** | If Analytics is down, messages wait in Kafka |
| **Exactly-once** | Kafka + idempotent consumers = no duplicate processing |
| **Multiple consumers** | One event, many subscribers (fan-out) |
| **Audit trail** | Kafka retains messages for replay if needed |

### Without Kafka (Why It's Bad)

```
Payment Service â”€â”€syncâ”€â”€â†’ Analytics     (what if Analytics is down?)
                â”€â”€syncâ”€â”€â†’ Billing       (what if Billing is slow?)
                â”€â”€syncâ”€â”€â†’ Accounting    (what if Accounting throws error?)
```

Problems: tight coupling, cascading failures, payment delayed by slowest consumer.

---

## 13. Handling Failed Payments

### Types of Failures

| Failure Type | Example | Retryable? |
|-------------|---------|------------|
| **Network timeout** | PSP didn't respond in time | Yes |
| **PSP temporary error** | 500 Internal Server Error | Yes |
| **Insufficient funds** | Customer's card declined | No |
| **Invalid card** | Wrong card number | No |
| **Fraud detected** | PSP blocked the transaction | No |

### Retry Flow with Dead Letter Queue

```
  Payment fails
       â”‚
       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     No      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚Retryable?â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚   Mark   â”‚  (insufficient funds, invalid card, fraud)
  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜              â”‚  FAILED  â”‚
       â”‚ Yes                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚         Retry Queue                 â”‚
  â”‚  (exponential backoff: 1s,2s,4s,8s) â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     Success    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ Retry   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚  Update  â”‚
          â”‚ Payment â”‚                â”‚ SUCCESS  â”‚
          â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ Fails again
               â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    No     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚Max retries â”‚â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚  Dead Letter  â”‚  (manual investigation)
         â”‚ exceeded?  â”‚           â”‚    Queue      â”‚
         â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ No
               â””â”€â”€â†’ Back to Retry Queue (next backoff interval)
```

**Exponential backoff:** 1s â†’ 2s â†’ 4s â†’ 8s â†’ 16s â†’ ... up to max retries (e.g., 5). After max retries â†’ **Dead Letter Queue (DLQ)** for manual investigation.

### What Is a Dead Letter Queue?

A DLQ is a special queue for messages that **failed all retry attempts**. These require human intervention:
- Investigate why the payment keeps failing
- Fix the issue manually
- Either retry from DLQ or mark as permanently failed

---

## 14. Exactly-Once Delivery

### The Problem

In distributed systems, messages can be delivered:
- **At-most-once**: Message might be lost (unacceptable for payments)
- **At-least-once**: Message might be delivered multiple times (dangerous â€” double charge)
- **Exactly-once**: Message is processed exactly one time (what we need)

True exactly-once is theoretically impossible in distributed systems. But we can achieve **effectively exactly-once** using: **at-least-once delivery + idempotent processing**.

### How It Works

```
at-least-once delivery  +  idempotent operations  =  effectively exactly-once
      (Kafka)                 (idempotency key)
```

**At-least-once**: Kafka guarantees every message is delivered at least once (via acks + retries). Messages might be delivered twice if a consumer crashes after processing but before committing the offset.

**Idempotent processing**: Every payment operation checks the idempotency key before executing. If the key was already processed â†’ return cached result, do nothing.

### Idempotency at Every Layer (Different Keys!)

```
Client â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Payment Service â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Payment Executor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ PSP
         Key A                        Key B
   (client-generated UUID)     (our payment_order_id)

Key A: protects against client retrying the same request to us
Key B: protects against our system retrying the same request to PSP
```

> Same **concept** at each layer (deduplication), but **different actual keys**. We can use our `payment_order_id` as the idempotency key to PSP since it's already unique per payment.

### Idempotency Key Lifecycle

1. **Client generates** Key A (a UUID): `d7e8f9a0-...`
2. **Sends it** in the `Idempotency-Key` header
3. **Payment Service** checks DB: does Key A exist?
   - Yes â†’ return existing result (no processing)
   - No â†’ INSERT new payment order with this key (UNIQUE constraint)
4. **Payment Executor** sends Key B (`payment_order_id`) to PSP as idempotency key
5. **PSP** checks on their side: did they see this key before?
   - Yes â†’ return existing charge result
   - No â†’ process the charge

> Even if our request to PSP times out and we retry, the PSP won't double-charge because they have our idempotency key.

---

## 15. Consistency

### The Challenge

A single payment touches multiple systems:
1. Payment DB (order status)
2. Wallet DB (seller balance)
3. Ledger DB (accounting entries)
4. PSP (external charge)

If step 3 fails after step 1 and 2 succeeded, we have an **inconsistent state**.

### Why Eventual Consistency Works Here

The overall payment flow is already **asynchronous** (webhook-based). The buyer doesn't sit and wait for the seller's wallet balance to update. So we don't need all updates to happen atomically â€” we just need them to **eventually** happen reliably.

### Solution: Transactional Outbox Pattern

```
Webhook arrives ("payment succeeded")
       â”‚
       â–¼
1. Payment Service writes to its DB (single ACID transaction):
   BEGIN TRANSACTION;
     UPDATE payment_orders SET status = 'SUCCESS';
     INSERT INTO outbox_table (event_type, payload) VALUES ('PAYMENT_SUCCESS', {...});
   COMMIT;
       â”‚
       â–¼
2. A separate process reads the outbox table â†’ publishes event to Kafka
   (two options: polling-based cron job, or CDC tool like Debezium
    that tails the DB's binlog â€” CDC is preferred for lower latency)
       â”‚
       â”œâ”€â”€â†’ Wallet Service consumes event â†’ updates seller balance
       â”‚
       â””â”€â”€â†’ Ledger Service consumes event â†’ writes double-entry records
```

- **payment_orders** is updated **synchronously** (source of truth â€” must be immediate)
- **Wallet** and **Ledger** are updated **asynchronously** via Kafka (may lag a few seconds â€” perfectly fine)
- If Wallet/Ledger update fails â†’ Kafka retries (at-least-once) + idempotent consumers = eventual consistency

> The **outbox pattern** ensures the DB write and the event publish either both happen or neither happens â€” by putting them in the same database transaction.

### Why Not a Single ACID Transaction for Everything?

You *could* do this if all tables are in one DB:

```sql
BEGIN TRANSACTION;
  UPDATE payment_orders SET status = 'SUCCESS';
  UPDATE wallets SET balance = balance + 99.99;
  INSERT INTO ledger_entries (...) VALUES (...);
COMMIT;
```

But this **doesn't scale** â€” as the system grows, Wallet and Ledger will likely move to separate databases/services. The outbox + Kafka approach is more resilient and decouples services.

### Why Not Distributed Transactions (2PC)?

Two-Phase Commit (2PC) across databases is:
- Slow (locks held across systems)
- Fragile (coordinator failure = everything blocked)
- Impractical with external PSPs (you can't run 2PC with Stripe)

**Eventual consistency + idempotency + reconciliation** is the industry standard for payment systems.

---

## 16. Security

### PCI DSS Compliance

The Payment Card Industry Data Security Standard (PCI DSS) mandates how card data must be handled:

| Level | Applies to | Requirements |
|-------|-----------|-------------|
| Level 1 | >6M transactions/year | Annual on-site audit, quarterly scans |
| Level 2 | 1-6M transactions/year | Annual self-assessment, quarterly scans |
| Level 3 | 20K-1M transactions/year | Annual self-assessment |
| Level 4 | <20K transactions/year | Annual self-assessment |

**Our approach**: By using a Hosted Payment Page (PSP handles card data), we reduce our PCI scope to **SAQ-A** (the simplest level). Card numbers never touch our servers.

### What We DO Store

| Data | Store? | Why |
|------|--------|-----|
| Credit card number | **NEVER** | PSP handles this |
| CVV | **NEVER** | Cannot be stored even by PSPs after auth |
| Card token (from PSP) | Yes | Used for recurring payments |
| Transaction amounts | Yes | Business records |
| Payment status | Yes | Order tracking |

### Additional Security Measures

- **TLS/HTTPS everywhere** â€” encrypt all communication
- **API authentication** â€” every request must have a valid auth token
- **Rate limiting** â€” prevent brute-force attacks
- **Fraud detection** â€” PSP provides this (unusual amount, location, velocity)
- **Tokenization** â€” PSP replaces card numbers with tokens; we store tokens, not cards

---

## 17. Complete System Design Summary

### Full Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Client Browser                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Checkout   â”‚  â”‚  Hosted Payment   â”‚  â”‚  Completion   â”‚  â”‚
â”‚  â”‚    Page     â”‚â”€â”€â”‚   Page (PSP's)    â”‚â”€â”€â”‚    Page       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                   â”‚
          â–¼                   â”‚ (card data goes to PSP directly)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Payment System (Internal)   â”‚                                â”‚
â”‚                             â”‚                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚                                â”‚
â”‚  â”‚  Payment Service â”‚â—„â”€â”€â”€â”€â”€â”€â”˜ (webhook with result)          â”‚
â”‚  â”‚  - idempotency   â”‚                                        â”‚
â”‚  â”‚  - orchestration â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”˜                  â”‚                     â”‚
â”‚      â”‚          â”‚                      â–¼                     â”‚
â”‚      â”‚    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚      â”‚    â”‚    Payment     â”‚â”€â”€â†’ â”‚     PSP      â”‚             â”‚
â”‚      â”‚    â”‚    Executor    â”‚    â”‚ (Stripe, etc)â”‚             â”‚
â”‚      â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚      â”‚                                 â”‚                     â”‚
â”‚  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚ Webhook             â”‚
â”‚  â”‚ Ledger â”‚  â”‚ Wallet â”‚               â”‚                     â”‚
â”‚  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜               â”‚                     â”‚
â”‚      â–¼           â–¼                     â”‚                     â”‚
â”‚    [DB]        [DB]                    â”‚                     â”‚
â”‚                                        â”‚                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚                     â”‚
â”‚  â”‚  Reconciliation    â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (settlement file)   â”‚
â”‚  â”‚  (daily batch job) â”‚                                      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                      â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                      â”‚
â”‚  â”‚      Kafka         â”‚â”€â”€â†’ Analytics, Billing, Accounting    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 18. Key Interview Talking Points

### "Walk me through what happens when a customer clicks Pay"

> The Payment Service receives the request, checks the idempotency key to prevent duplicate charges, and creates a payment order. It then redirects the user to the PSP's Hosted Payment Page â€” the user enters card details there, so card data never touches our servers. The PSP processes the charge via card networks (Visa/Mastercard) and sends us the result via a webhook. On success, we update the payment status, record double-entry ledger entries (debit buyer, credit seller), and update the seller's wallet balance.

### "How do you prevent a customer from being charged twice?"

> Idempotency keys at every layer. The client generates a UUID and sends it in the header. Our Payment Service checks this key against a UNIQUE database constraint â€” if it exists, we return the cached result. We also forward the key to the PSP, so even if our request times out and we retry, the PSP won't double-charge. It's effectively exactly-once: at-least-once delivery + idempotent processing.

### "What is double-entry ledger and why use it?"

> Every payment creates two entries: a debit (money leaves buyer) and a credit (money enters seller). The invariant is that total debits must always equal total credits. This gives us error detection (imbalance = bug), an immutable audit trail (entries are append-only, never modified), and standard accounting that auditors understand. Corrections are done by adding new reversal entries, not editing old ones.

### "How do you handle consistency across services?"

> For components in the same database, we use ACID transactions. For separate databases, we use the transactional outbox pattern: write the DB update and an event to an outbox table in a single transaction, then a separate process publishes to Kafka. Downstream consumers are idempotent. As the final safety net, daily reconciliation compares our records against PSP settlement files to catch any discrepancies.

### "What happens when a payment fails?"

> We check if the failure is retryable (network timeout, PSP 500) or permanent (insufficient funds, invalid card). Retryable failures go to a retry queue with exponential backoff. After max retries, they're moved to a Dead Letter Queue for manual investigation. Non-retryable failures are immediately recorded as FAILED.

---

## 19. Common Mistakes to Avoid

| Mistake | Why It's Wrong | Better Approach |
|---------|---------------|-----------------|
| Storing credit card numbers | PCI compliance nightmare | Use PSP's hosted payment page |
| No idempotency key | Double charges on retry | Idempotency key at every layer |
| Synchronous inter-service calls | Cascading failures | Kafka for async communication |
| Mutable ledger entries | No audit trail, fraud risk | Append-only ledger, corrections via reversal entries |
| No reconciliation | Silent data inconsistencies | Daily reconciliation against PSP settlement files |
| 2PC across databases | Slow, fragile, impractical with PSPs | Eventual consistency + idempotency + reconciliation |
| Polling PSP for payment result | Wasteful, doesn't scale | Webhooks for async result delivery |
| Ignoring dead letter queue | Failed payments silently lost | DLQ + alerting for manual investigation |
